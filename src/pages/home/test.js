const TRIANGULATION = [127, 34, 139, 11, 0, 37, 232, 231, 120, 72, 37, 39, 128, 121, 47, 232, 121, 128, 104, 69, 67, 175, 171, 148, 157, 154, 155, 118, 50, 101, 73, 39, 40, 9, 151, 108, 48, 115, 131, 194, 204, 211, 74, 40, 185, 80, 42, 183, 40, 92, 186, 230, 229, 118, 202, 212, 214, 83, 18, 17, 76, 61, 146, 160, 29, 30, 56, 157, 173, 106, 204, 194, 135, 214, 192, 203, 165, 98, 21, 71, 68, 51, 45, 4, 144, 24, 23, 77, 146, 91, 205, 50, 187, 201, 200, 18, 91, 106, 182, 90, 91, 181, 85, 84, 17, 206, 203, 36, 148, 171, 140, 92, 40, 39, 193, 189, 244, 159, 158, 28, 247, 246, 161, 236, 3, 196, 54, 68, 104, 193, 168, 8, 117, 228, 31, 189, 193, 55, 98, 97, 99, 126, 47, 100, 166, 79, 218, 155, 154, 26, 209, 49, 131, 135, 136, 150, 47, 126, 217, 223, 52, 53, 45, 51, 134, 211, 170, 140, 67, 69, 108, 43, 106, 91, 230, 119, 120, 226, 130, 247, 63, 53, 52, 238, 20, 242, 46, 70, 156, 78, 62, 96, 46, 53, 63, 143, 34, 227, 173, 155, 133, 123, 117, 111, 44, 125, 19, 236, 134, 51, 216, 206, 205, 154, 153, 22, 39, 37, 167, 200, 201, 208, 36, 142, 100, 57, 212, 202, 20, 60, 99, 28, 158, 157, 35, 226, 113, 160, 159, 27, 204, 202, 210, 113, 225, 46, 43, 202, 204, 62, 76, 77, 137, 123, 116, 41, 38, 72, 203, 129, 142, 64, 98, 240, 49, 102, 64, 41, 73, 74, 212, 216, 207, 42, 74, 184, 169, 170, 211, 170, 149, 176, 105, 66, 69, 122, 6, 168, 123, 147, 187, 96, 77, 90, 65, 55, 107, 89, 90, 180, 101, 100, 120, 63, 105, 104, 93, 137, 227, 15, 86, 85, 129, 102, 49, 14, 87, 86, 55, 8, 9, 100, 47, 121, 145, 23, 22, 88, 89, 179, 6, 122, 196, 88, 95, 96, 138, 172, 136, 215, 58, 172, 115, 48, 219, 42, 80, 81, 195, 3, 51, 43, 146, 61, 171, 175, 199, 81, 82, 38, 53, 46, 225, 144, 163, 110, 246, 33, 7, 52, 65, 66, 229, 228, 117, 34, 127, 234, 107, 108, 69, 109, 108, 151, 48, 64, 235, 62, 78, 191, 129, 209, 126, 111, 35, 143, 163, 161, 246, 117, 123, 50, 222, 65, 52, 19, 125, 141, 221, 55, 65, 3, 195, 197, 25, 7, 33, 220, 237, 44, 70, 71, 139, 122, 193, 245, 247, 130, 33, 71, 21, 162, 153, 158, 159, 170, 169, 150, 188, 174, 196, 216, 186, 92, 144, 160, 161, 2, 97, 167, 141, 125, 241, 164, 167, 37, 72, 38, 12, 145, 159, 160, 38, 82, 13, 63, 68, 71, 226, 35, 111, 158, 153, 154, 101, 50, 205, 206, 92, 165, 209, 198, 217, 165, 167, 97, 220, 115, 218, 133, 112, 243, 239, 238, 241, 214, 135, 169, 190, 173, 133, 171, 208, 32, 125, 44, 237, 86, 87, 178, 85, 86, 179, 84, 85, 180, 83, 84, 181, 201, 83, 182, 137, 93, 132, 76, 62, 183, 61, 76, 184, 57, 61, 185, 212, 57, 186, 214, 207, 187, 34, 143, 156, 79, 239, 237, 123, 137, 177, 44, 1, 4, 201, 194, 32, 64, 102, 129, 213, 215, 138, 59, 166, 219, 242, 99, 97, 2, 94, 141, 75, 59, 235, 24, 110, 228, 25, 130, 226, 23, 24, 229, 22, 23, 230, 26, 22, 231, 112, 26, 232, 189, 190, 243, 221, 56, 190, 28, 56, 221, 27, 28, 222, 29, 27, 223, 30, 29, 224, 247, 30, 225, 238, 79, 20, 166, 59, 75, 60, 75, 240, 147, 177, 215, 20, 79, 166, 187, 147, 213, 112, 233, 244, 233, 128, 245, 128, 114, 188, 114, 217, 174, 131, 115, 220, 217, 198, 236, 198, 131, 134, 177, 132, 58, 143, 35, 124, 110, 163, 7, 228, 110, 25, 356, 389, 368, 11, 302, 267, 452, 350, 349, 302, 303, 269, 357, 343, 277, 452, 453, 357, 333, 332, 297, 175, 152, 377, 384, 398, 382, 347, 348, 330, 303, 304, 270, 9, 336, 337, 278, 279, 360, 418, 262, 431, 304, 408, 409, 310, 415, 407, 270, 409, 410, 450, 348, 347, 422, 430, 434, 313, 314, 17, 306, 307, 375, 387, 388, 260, 286, 414, 398, 335, 406, 418, 364, 367, 416, 423, 358, 327, 251, 284, 298, 281, 5, 4, 373, 374, 253, 307, 320, 321, 425, 427, 411, 421, 313, 18, 321, 405, 406, 320, 404, 405, 315, 16, 17, 426, 425, 266, 377, 400, 369, 322, 391, 269, 417, 465, 464, 386, 257, 258, 466, 260, 388, 456, 399, 419, 284, 332, 333, 417, 285, 8, 346, 340, 261, 413, 441, 285, 327, 460, 328, 355, 371, 329, 392, 439, 438, 382, 341, 256, 429, 420, 360, 364, 394, 379, 277, 343, 437, 443, 444, 283, 275, 440, 363, 431, 262, 369, 297, 338, 337, 273, 375, 321, 450, 451, 349, 446, 342, 467, 293, 334, 282, 458, 461, 462, 276, 353, 383, 308, 324, 325, 276, 300, 293, 372, 345, 447, 382, 398, 362, 352, 345, 340, 274, 1, 19, 456, 248, 281, 436, 427, 425, 381, 256, 252, 269, 391, 393, 200, 199, 428, 266, 330, 329, 287, 273, 422, 250, 462, 328, 258, 286, 384, 265, 353, 342, 387, 259, 257, 424, 431, 430, 342, 353, 276, 273, 335, 424, 292, 325, 307, 366, 447, 345, 271, 303, 302, 423, 266, 371, 294, 455, 460, 279, 278, 294, 271, 272, 304, 432, 434, 427, 272, 407, 408, 394, 430, 431, 395, 369, 400, 334, 333, 299, 351, 417, 168, 352, 280, 411, 325, 319, 320, 295, 296, 336, 319, 403, 404, 330, 348, 349, 293, 298, 333, 323, 454, 447, 15, 16, 315, 358, 429, 279, 14, 15, 316, 285, 336, 9, 329, 349, 350, 374, 380, 252, 318, 402, 403, 6, 197, 419, 318, 319, 325, 367, 364, 365, 435, 367, 397, 344, 438, 439, 272, 271, 311, 195, 5, 281, 273, 287, 291, 396, 428, 199, 311, 271, 268, 283, 444, 445, 373, 254, 339, 263, 466, 249, 282, 334, 296, 449, 347, 346, 264, 447, 454, 336, 296, 299, 338, 10, 151, 278, 439, 455, 292, 407, 415, 358, 371, 355, 340, 345, 372, 390, 249, 466, 346, 347, 280, 442, 443, 282, 19, 94, 370, 441, 442, 295, 248, 419, 197, 263, 255, 359, 440, 275, 274, 300, 383, 368, 351, 412, 465, 263, 467, 466, 301, 368, 389, 380, 374, 386, 395, 378, 379, 412, 351, 419, 436, 426, 322, 373, 390, 388, 2, 164, 393, 370, 462, 461, 164, 0, 267, 302, 11, 12, 374, 373, 387, 268, 12, 13, 293, 300, 301, 446, 261, 340, 385, 384, 381, 330, 266, 425, 426, 423, 391, 429, 355, 437, 391, 327, 326, 440, 457, 438, 341, 382, 362, 459, 457, 461, 434, 430, 394, 414, 463, 362, 396, 369, 262, 354, 461, 457, 316, 403, 402, 315, 404, 403, 314, 405, 404, 313, 406, 405, 421, 418, 406, 366, 401, 361, 306, 408, 407, 291, 409, 408, 287, 410, 409, 432, 436, 410, 434, 416, 411, 264, 368, 383, 309, 438, 457, 352, 376, 401, 274, 275, 4, 421, 428, 262, 294, 327, 358, 433, 416, 367, 289, 455, 439, 462, 370, 326, 2, 326, 370, 305, 460, 455, 254, 449, 448, 255, 261, 446, 253, 450, 449, 252, 451, 450, 256, 452, 451, 341, 453, 452, 413, 464, 463, 441, 413, 414, 258, 442, 441, 257, 443, 442, 259, 444, 443, 260, 445, 444, 467, 342, 445, 459, 458, 250, 289, 392, 290, 290, 328, 460, 376, 433, 435, 250, 290, 392, 411, 416, 433, 341, 463, 464, 453, 464, 465, 357, 465, 412, 343, 412, 399, 360, 363, 440, 437, 399, 456, 420, 456, 363, 401, 435, 288, 372, 383, 353, 339, 255, 249, 448, 261, 255, 133, 243, 190, 133, 155, 112, 33, 246, 247, 33, 130, 25, 398, 384, 286, 362, 398, 414, 362, 463, 341, 263, 359, 467, 263, 249, 255, 466, 467, 260, 75, 60, 166, 238, 239, 79, 162, 127, 139, 72, 11, 37, 121, 232, 120, 73, 72, 39, 114, 128, 47, 233, 232, 128, 103, 104, 67, 152, 175, 148, 173, 157, 155, 119, 118, 101, 74, 73, 40, 107, 9, 108, 49, 48, 131, 32, 194, 211, 184, 74, 185, 191, 80, 183, 185, 40, 186, 119, 230, 118, 210, 202, 214, 84, 83, 17, 77, 76, 146, 161, 160, 30, 190, 56, 173, 182, 106, 194, 138, 135, 192, 129, 203, 98, 54, 21, 68, 5, 51, 4, 145, 144, 23, 90, 77, 91, 207, 205, 187, 83, 201, 18, 181, 91, 182, 180, 90, 181, 16, 85, 17, 205, 206, 36, 176, 148, 140, 165, 92, 39, 245, 193, 244, 27, 159, 28, 30, 247, 161, 174, 236, 196, 103, 54, 104, 55, 193, 8, 111, 117, 31, 221, 189, 55, 240, 98, 99, 142, 126, 100, 219, 166, 218, 112, 155, 26, 198, 209, 131, 169, 135, 150, 114, 47, 217, 224, 223, 53, 220, 45, 134, 32, 211, 140, 109, 67, 108, 146, 43, 91, 231, 230, 120, 113, 226, 247, 105, 63, 52, 241, 238, 242, 124, 46, 156, 95, 78, 96, 70, 46, 63, 116, 143, 227, 116, 123, 111, 1, 44, 19, 3, 236, 51, 207, 216, 205, 26, 154, 22, 165, 39, 167, 199, 200, 208, 101, 36, 100, 43, 57, 202, 242, 20, 99, 56, 28, 157, 124, 35, 113, 29, 160, 27, 211, 204, 210, 124, 113, 46, 106, 43, 204, 96, 62, 77, 227, 137, 116, 73, 41, 72, 36, 203, 142, 235, 64, 240, 48, 49, 64, 42, 41, 74, 214, 212, 207, 183, 42, 184, 210, 169, 211, 140, 170, 176, 104, 105, 69, 193, 122, 168, 50, 123, 187, 89, 96, 90, 66, 65, 107, 179, 89, 180, 119, 101, 120, 68, 63, 104, 234, 93, 227, 16, 15, 85, 209, 129, 49, 15, 14, 86, 107, 55, 9, 120, 100, 121, 153, 145, 22, 178, 88, 179, 197, 6, 196, 89, 88, 96, 135, 138, 136, 138, 215, 172, 218, 115, 219, 41, 42, 81, 5, 195, 51, 57, 43, 61, 208, 171, 199, 41, 81, 38, 224, 53, 225, 24, 144, 110, 105, 52, 66, 118, 229, 117, 227, 34, 234, 66, 107, 69, 10, 109, 151, 219, 48, 235, 183, 62, 191, 142, 129, 126, 116, 111, 143, 7, 163, 246, 118, 117, 50, 223, 222, 52, 94, 19, 141, 222, 221, 65, 196, 3, 197, 45, 220, 44, 156, 70, 139, 188, 122, 245, 139, 71, 162, 145, 153, 159, 149, 170, 150, 122, 188, 196, 206, 216, 92, 163, 144, 161, 164, 2, 167, 242, 141, 241, 0, 164, 37, 11, 72, 12, 144, 145, 160, 12, 38, 13, 70, 63, 71, 31, 226, 111, 157, 158, 154, 36, 101, 205, 203, 206, 165, 126, 209, 217, 98, 165, 97, 237, 220, 218, 237, 239, 241, 210, 214, 169, 140, 171, 32, 241, 125, 237, 179, 86, 178, 180, 85, 179, 181, 84, 180, 182, 83, 181, 194, 201, 182, 177, 137, 132, 184, 76, 183, 185, 61, 184, 186, 57, 185, 216, 212, 186, 192, 214, 187, 139, 34, 156, 218, 79, 237, 147, 123, 177, 45, 44, 4, 208, 201, 32, 98, 64, 129, 192, 213, 138, 235, 59, 219, 141, 242, 97, 97, 2, 141, 240, 75, 235, 229, 24, 228, 31, 25, 226, 230, 23, 229, 231, 22, 230, 232, 26, 231, 233, 112, 232, 244, 189, 243, 189, 221, 190, 222, 28, 221, 223, 27, 222, 224, 29, 223, 225, 30, 224, 113, 247, 225, 99, 60, 240, 213, 147, 215, 60, 20, 166, 192, 187, 213, 243, 112, 244, 244, 233, 245, 245, 128, 188, 188, 114, 174, 134, 131, 220, 174, 217, 236, 236, 198, 134, 215, 177, 58, 156, 143, 124, 25, 110, 7, 31, 228, 25, 264, 356, 368, 0, 11, 267, 451, 452, 349, 267, 302, 269, 350, 357, 277, 350, 452, 357, 299, 333, 297, 396, 175, 377, 381, 384, 382, 280, 347, 330, 269, 303, 270, 151, 9, 337, 344, 278, 360, 424, 418, 431, 270, 304, 409, 272, 310, 407, 322, 270, 410, 449, 450, 347, 432, 422, 434, 18, 313, 17, 291, 306, 375, 259, 387, 260, 424, 335, 418, 434, 364, 416, 391, 423, 327, 301, 251, 298, 275, 281, 4, 254, 373, 253, 375, 307, 321, 280, 425, 411, 200, 421, 18, 335, 321, 406, 321, 320, 405, 314, 315, 17, 423, 426, 266, 396, 377, 369, 270, 322, 269, 413, 417, 464, 385, 386, 258, 248, 456, 419, 298, 284, 333, 168, 417, 8, 448, 346, 261, 417, 413, 285, 326, 327, 328, 277, 355, 329, 309, 392, 438, 381, 382, 256, 279, 429, 360, 365, 364, 379, 355, 277, 437, 282, 443, 283, 281, 275, 363, 395, 431, 369, 299, 297, 337, 335, 273, 321, 348, 450, 349, 359, 446, 467, 283, 293, 282, 250, 458, 462, 300, 276, 383, 292, 308, 325, 283, 276, 293, 264, 372, 447, 346, 352, 340, 354, 274, 19, 363, 456, 281, 426, 436, 425, 380, 381, 252, 267, 269, 393, 421, 200, 428, 371, 266, 329, 432, 287, 422, 290, 250, 328, 385, 258, 384, 446, 265, 342, 386, 387, 257, 422, 424, 430, 445, 342, 276, 422, 273, 424, 306, 292, 307, 352, 366, 345, 268, 271, 302, 358, 423, 371, 327, 294, 460, 331, 279, 294, 303, 271, 304, 436, 432, 427, 304, 272, 408, 395, 394, 431, 378, 395, 400, 296, 334, 299, 6, 351, 168, 376, 352, 411, 307, 325, 320, 285, 295, 336, 320, 319, 404, 329, 330, 349, 334, 293, 333, 366, 323, 447, 316, 15, 315, 331, 358, 279, 317, 14, 316, 8, 285, 9, 277, 329, 350, 253, 374, 252, 319, 318, 403, 351, 6, 419, 324, 318, 325, 397, 367, 365, 288, 435, 397, 278, 344, 439, 310, 272, 311, 248, 195, 281, 375, 273, 291, 175, 396, 199, 312, 311, 268, 276, 283, 445, 390, 373, 339, 295, 282, 296, 448, 449, 346, 356, 264, 454, 337, 336, 299, 337, 338, 151, 294, 278, 455, 308, 292, 415, 429, 358, 355, 265, 340, 372, 388, 390, 466, 352, 346, 280, 295, 442, 282, 354, 19, 370, 285, 441, 295, 195, 248, 197, 457, 440, 274, 301, 300, 368, 417, 351, 465, 251, 301, 389, 385, 380, 386, 394, 395, 379, 399, 412, 419, 410, 436, 322, 387, 373, 388, 326, 2, 393, 354, 370, 461, 393, 164, 267, 268, 302, 12, 386, 374, 387, 312, 268, 13, 298, 293, 301, 265, 446, 340, 380, 385, 381, 280, 330, 425, 322, 426, 391, 420, 429, 437, 393, 391, 326, 344, 440, 438, 458, 459, 461, 364, 434, 394, 428, 396, 262, 274, 354, 457, 317, 316, 402, 316, 315, 403, 315, 314, 404, 314, 313, 405, 313, 421, 406, 323, 366, 361, 292, 306, 407, 306, 291, 408, 291, 287, 409, 287, 432, 410, 427, 434, 411, 372, 264, 383, 459, 309, 457, 366, 352, 401, 1, 274, 4, 418, 421, 262, 331, 294, 358, 435, 433, 367, 392, 289, 439, 328, 462, 326, 94, 2, 370, 289, 305, 455, 339, 254, 448, 359, 255, 446, 254, 253, 449, 253, 252, 450, 252, 256, 451, 256, 341, 452, 414, 413, 463, 286, 441, 414, 286, 258, 441, 258, 257, 442, 257, 259, 443, 259, 260, 444, 260, 467, 445, 309, 459, 250, 305, 289, 290, 305, 290, 460, 401, 376, 435, 309, 250, 392, 376, 411, 433, 453, 341, 464, 357, 453, 465, 343, 357, 412, 437, 343, 399, 344, 360, 440, 420, 437, 456, 360, 420, 363, 361, 401, 288, 265, 372, 353, 390, 339, 249, 339, 448, 255],
    UVS = [.499976992607117, .34746599197387695, .500025987625122, .45251297950744596, .499974012374878, .397628009319305, .482113003730774, .528020977973938, .500150978565216, .47284400463104204, .499909996986389, .5017470121383669, .499523013830185, .59893798828125, .289712011814117, .6192359924316411, .499954998493195, .687601983547211, .499987006187439, .730081021785736, .500023007392883, .892949998378754, .500023007392883, .33376598358154297, .5000159740448, .320775985717773, .500023007392883, .30765199661254905, .499976992607117, .30472201108932495, .499976992607117, .29406601190567005, .499976992607117, .280614972114563, .499976992607117, .262980997562408, .499967992305756, .21862900257110596, .499816000461578, .43701899051666304, .473773002624512, .42609000205993697, .104906998574734, .745859026908875, .365929991006851, .590424001216888, .338757991790771, .58697497844696, .311120003461838, .590539991855621, .274657994508743, .6108689904212949, .393361985683441, .596293985843658, .345234006643295, .655988991260529, .370094001293182, .6539239883422849, .319321990013123, .652734994888306, .297903001308441, .646408975124359, .24779200553894, .589190006256104, .396889001131058, .15724498033523604, .280097991228104, .6244000196456909, .106310002505779, .6000440120697019, .2099249958992, .6086469888687129, .355807989835739, .46559399366378795, .471751004457474, .34959602355957, .474155008792877, .319808006286621, .439785003662109, .342770993709564, .414617002010345, .33345901966095004, .450374007225037, .319139003753662, .428770989179611, .31730902194976796, .374971002340317, .272194981575012, .486716985702515, .452371001243591, .485300987958908, .47260499000549305, .257764995098114, .685509979724884, .401223003864288, .544827997684479, .429818987846375, .451385021209717, .421351999044418, .466259002685547, .276895999908447, .467943012714386, .483370006084442, .500413000583649, .33721199631691, .7171170115470891, .296391993761063, .706757009029388, .169294998049736, .806186020374298, .447580009698868, .697390019893646, .392390012741089, .646112024784088, .354490011930466, .30321598052978505, .067304998636246, .269894957542419, .442739009857178, .427173972129822, .457098007202148, .415207982063293, .381974011659622, .305289030075073, .392388999462128, .305796980857849, .277076005935669, .728067994117737, .422551989555359, .436766982078552, .385919004678726, .718635976314545, .383103013038635, .744159996509552, .331431001424789, .880285978317261, .229923993349075, .767997026443481, .364500999450684, .810886025428772, .229622006416321, .700459003448486, .173287004232407, .721252024173737, .472878992557526, .33380198478698697, .446828007698059, .331472992897034, .422762006521225, .32611000537872303, .445307999849319, .41993403434753396, .388103008270264, .306038975715637, .403039008378983, .293460011482239, .403629004955292, .306046962738037, .460041999816895, .44286096096038796, .431158006191254, .307633996009827, .452181994915009, .307633996009827, .475387006998062, .307633996009827, .465828001499176, .22080999612808205, .472328990697861, .263774037361145, .473087012767792, .282142996788025, .473122000694275, .295374035835266, .473033010959625, .30472201108932495, .427942007780075, .30472201108932495, .426479011774063, .29646003246307395, .423162013292313, .28815400600433305, .4183090031147, .27993702888488803, .390094995498657, .360427021980286, .013953999616206, .439965963363647, .499913990497589, .41985297203064, .413199990987778, .30460000038146995, .409626007080078, .29817700386047397, .468080013990402, .398465037345886, .422728985548019, .414014995098114, .463079988956451, .406216025352478, .37211999297142, .52658599615097, .334562003612518, .5039269924163821, .411671012639999, .45303499698638905, .242175996303558, .85232400894165, .290776997804642, .798554003238678, .327338010072708, .7434729933738711, .399509996175766, .251078963279724, .441727995872498, .738323986530304, .429764986038208, .8121659755706789, .412198007106781, .891098976135254, .288955003023148, .601047992706299, .218936994671822, .564589023590088, .41278201341629, .601029992103577, .257135003805161, .644559979438782, .427684992551804, .562039017677307, .448339998722076, .46306395530700695, .178560003638268, .54244601726532, .247308000922203, .542806029319763, .286267012357712, .532325029373169, .332827985286713, .5392879843711851, .368755996227264, .552793025970459, .398963987827301, .567345023155212, .476410001516342, .594193994998932, .189241006970406, .47607600688934304, .228962004184723, .651049017906189, .490725994110107, .43759900331497203, .404670000076294, .514867007732391, .019469000399113, .598435997962952, .426243007183075, .5795689821243291, .396993011236191, .451202988624573, .266469985246658, .6230229735374451, .439121007919312, .48104202747345004, .032313998788595, .355643033981323, .419054001569748, .612845003604889, .462783008813858, .49425303936004605, .238978996872902, .22025501728057895, .198220998048782, .16806197166442904, .107550002634525, .459244966506958, .183610007166862, .259742975234985, .134409993886948, .6663169860839839, .385764002799988, .11684602499008201, .490967005491257, .42062199115753196, .382384985685349, .491427004337311, .174399003386497, .602329015731812, .318785011768341, .60376501083374, .343364000320435, .599403023719788, .396100014448166, .28978300094604503, .187885001301765, .41146200895309404, .430987000465393, .05593502521514904, .318993002176285, .101714968681335, .266247987747192, .130298972129822, .500023007392883, .809423983097076, .499976992607117, .045547008514403964, .366169989109039, .601177990436554, .393207013607025, .6044629812240601, .410373002290726, .608919978141785, .194993004202843, .657898008823395, .388664990663528, .6377159953117371, .365961998701096, .644029021263123, .343364000320435, .6446430087089541, .318785011768341, .64165997505188, .301414996385574, .636843979358673, .058132998645306, .680923998355865, .301414996385574, .612550973892212, .499987989664078, .38156598806381203, .415838003158569, .375804007053375, .445681989192963, .43392300605773904, .465844005346298, .379359006881714, .49992299079895, .648476004600525, .288718998432159, .180054008960724, .335278987884521, .14718002080917403, .440512001514435, .09758102893829301, .128294005990028, .20805901288986195, .408771991729736, .6261060237884519, .455606997013092, .548198997974396, .499877005815506, .09100997447967496, .375436991453171, .07580798864364602, .11421000212431, .38497799634933505, .448662012815475, .30472201108932495, .4480200111866, .295367956161499, .447111994028091, .28419196605682395, .444831997156143, .269205987453461, .430011987686157, .23319101333618197, .406787008047104, .31432700157165505, .400738000869751, .318930983543396, .392399996519089, .32229697704315197, .367855995893478, .33608102798461903, .247923001646996, .39866697788238503, .452769994735718, .579150021076202, .43639200925827, .640112996101379, .416164010763168, .631286025047302, .413385987281799, .307633996009827, .228018000721931, .316428005695343, .468268007040024, .6473289728164671, .411361992359161, .195672988891602, .499989002943039, .530174970626831, .479153990745544, .557345986366272, .499974012374878, .5603629946708679, .432112008333206, .506411015987396, .499886006116867, .13308298587799094, .49991300702095, .17827099561691295, .456548988819122, .18079900741577104, .344549000263214, .254561007022858, .37890899181366, .425989985466003, .374292999505997, .219815015792847, .319687992334366, .42926204204559304, .357154995203018, .395730018615723, .295284003019333, .37841904163360596, .447750002145767, .137522995471954, .410986006259918, .491276979446411, .31395098567009, .22469198703765902, .354128003120422, .187447011470795, .324548006057739, .296007037162781, .189096003770828, .35370004177093495, .279776990413666, .28534197807312, .1338230073452, .317299008369446, .336768001317978, .35526698827743497, .429883986711502, .533478021621704, .455527991056442, .451377034187317, .437114000320435, .441103994846344, .467287987470627, .47007501125335704, .414712011814117, .6647800207138059, .37704598903656, .677222013473511, .344107985496521, .679849028587341, .312875986099243, .67766797542572, .283526003360748, .6668099761009221, .241245999932289, .617214024066925, .102986000478268, .531237006187439, .267612010240555, .575439989566803, .297879010438919, .5668240189552309, .333433985710144, .5661219954490659, .366427004337311, .573884010314941, .396012008190155, .583303987979889, .420121014118195, .58977198600769, .007561000064015, .519222974777222, .432949006557465, .43048202991485596, .458638995885849, .520910978317261, .473466008901596, .45425599813461304, .476087987422943, .43616998195648204, .468472003936768, .444943010807037, .433990985155106, .417638003826141, .483518004417419, .43701601028442405, .482482999563217, .42215096950530995, .42645001411438, .6102010011672969, .438998997211456, .60350501537323, .450067013502121, .599565982818604, .289712011814117, .631747007369995, .276670008897781, .636627018451691, .517862021923065, .528051972389221, .710287988185883, .6192359924316411, .526226997375488, .42609000205993697, .895093023777008, .745859026908875, .634069979190826, .590424001216888, .661242008209229, .58697497844696, .688880026340485, .590539991855621, .725341975688934, .6108689904212949, .606630027294159, .5962949991226201, .654766023159027, .655988991260529, .629905998706818, .6539239883422849, .680678009986877, .652734994888306, .702096998691559, .646408975124359, .75221198797226, .589195013046265, .602918028831482, .15713703632354703, .719901978969574, .6244000196456909, .893692970275879, .600040018558502, .790081977844238, .608645975589752, .643998026847839, .465512037277222, .528249025344849, .34959602355957, .525849997997284, .31980895996093806, .560214996337891, .342770993709564, .585384011268616, .33345901966095004, .549625992774963, .319139003753662, .57122802734375, .317308008670807, .624852001667023, .27190101146698, .513050019741058, .45271801948547397, .51509702205658, .472748041152954, .742246985435486, .685492992401123, .598631024360657, .545020997524261, .570338010787964, .451424956321716, .578631997108459, .46637701988220204, .723087012767792, .467945992946625, .516445994377136, .500361025333405, .662801027297974, .717082023620605, .70362401008606, .706728994846344, .830704987049103, .806186020374298, .552385985851288, .697431981563568, .607609987258911, .646112024784088, .645429015159607, .30329298973083496, .932694971561432, .269894957542419, .557260990142822, .427173972129822, .542901992797852, .415207982063293, .6180260181427, .305289030075073, .607590973377228, .305796980857849, .722943007946014, .7280369997024541, .577413976192474, .43683302402496305, .614082992076874, .7186130285263059, .616907000541687, .744113981723785, .668509006500244, .880086004734039, .770092010498047, .767979025840759, .635536015033722, .8107510209083559, .77039098739624, .7004439830780029, .826722025871277, .7212449908256531, .527121007442474, .33380198478698697, .553171992301941, .331472992897034, .577238023281097, .32611000537872303, .554691970348358, .41993403434753396, .611896991729736, .306038975715637, .59696102142334, .293460011482239, .596370995044708, .306046962738037, .539958000183105, .44286096096038796, .568841993808746, .307633996009827, .547818005084991, .307633996009827, .52461302280426, .307633996009827, .534089982509613, .22085899114608798, .527670979499817, .263774037361145, .526912987232208, .282142996788025, .526877999305725, .295374035835266, .526966989040375, .30472201108932495, .572058022022247, .30472201108932495, .573521018028259, .29646003246307395, .57683801651001, .28815400600433305, .581691026687622, .27993702888488803, .609944999217987, .36009001731872603, .986046016216278, .439965963363647, .5867999792099, .30460000038146995, .590372025966644, .29817700386047397, .531915009021759, .398463010787964, .577268004417419, .414065003395081, .536915004253387, .406213998794556, .627542972564697, .526647984981537, .665585994720459, .5040490031242371, .588353991508484, .45313799381256104, .757824003696442, .85232400894165, .709249973297119, .798492014408112, .672684013843536, .743418991565704, .600408971309662, .25099503993988004, .55826598405838, .738327980041504, .570303976535797, .812129020690918, .588165998458862, .890955984592438, .711045026779175, .601047992706299, .781069993972778, .564594984054565, .587247014045715, .601068019866943, .742869973182678, .644554018974304, .572156012058258, .562348008155823, .55186802148819, .46342998743057295, .821442008018494, .542443990707397, .752701997756958, .542818009853363, .71375697851181, .532373011112213, .66711300611496, .539327025413513, .631101012229919, .552846014499664, .6008620262146, .567526996135712, .523481011390686, .5943729877471919, .810747981071472, .476073980331421, .771045982837677, .6510409712791441, .509127020835876, .43728196620941195, .595292985439301, .514976024627686, .980530977249146, .598435997962952, .573499977588654, .579999983310699, .602994978427887, .45131200551986705, .733529984951019, .6230229735374451, .560611009597778, .48098301887512196, .967685997486115, .355643033981323, .580985009670258, .612839996814728, .537728011608124, .494614958763123, .760966002941132, .22024703025817904, .801778972148895, .16806197166442904, .892440974712372, .45923900604248, .816350996494293, .259739995002747, .865594983100891, .666312992572784, .614073991775513, .11675399541854903, .508952975273132, .42056202888488803, .617941975593567, .49168395996093806, .825608015060425, .602325022220612, .681214988231659, .60376501083374, .656635999679565, .599403023719788, .603900015354156, .28978300094604503, .81208598613739, .41146099567413297, .56801301240921, .05543500185012795, .681007981300354, .101714968681335, .733752012252808, .130298972129822, .633830010890961, .601177990436554, .606792986392975, .6044629812240601, .589659988880157, .6089379787445071, .805015981197357, .657891988754272, .611334979534149, .6377159953117371, .634037971496582, .644029021263123, .656635999679565, .6446430087089541, .681214988231659, .64165997505188, .698584973812103, .636843979358673, .941866993904114, .680923998355865, .698584973812103, .612550973892212, .584177017211914, .375892996788025, .554318010807037, .43392300605773904, .534153997898102, .37935996055603005, .711217999458313, .18002498149871804, .664629995822906, .14712899923324596, .559099972248077, .09736800193786599, .871706008911133, .20805901288986195, .591234028339386, .6261060237884519, .544341027736664, .548416018486023, .624562978744507, .07580798864364602, .88577002286911, .384971022605896, .551338016986847, .30472201108932495, .551980018615723, .295367956161499, .552887976169586, .28419196605682395, .555167973041534, .269205987453461, .569944024085999, .23296499252319303, .593203008174896, .31432402133941695, .599261999130249, .318930983543396, .607599973678589, .32229697704315197, .631937980651855, .33649998903274503, .752032995223999, .398684978485107, .547226011753082, .579604983329773, .563543975353241, .640172004699707, .583841025829315, .631286025047302, .586614012718201, .307633996009827, .771915018558502, .31642198562622104, .531597018241882, .647517025470734, .588370978832245, .19555902481079102, .52079701423645, .5574349761009221, .567984998226166, .5065209865570071, .543282985687256, .18074500560760498, .655317008495331, .25448501110076904, .621008992195129, .42598199844360396, .625559985637665, .21968799829483, .680198013782501, .42928099632263195, .64276397228241, .39566200971603405, .704662978649139, .378470003604889, .552012026309967, .13740801811218295, .589071989059448, .491362988948822, .685944974422455, .224642992019653, .645735025405884, .18735998868942305, .675342977046967, .29602199792861905, .810858011245728, .35369503498077404, .72012197971344, .28533303737640403, .866151988506317, .31729501485824596, .663187026977539, .35540300607681297, .570082008838654, .533674001693726, .544561982154846, .451624035835266, .562758982181549, .441215038299561, .531987011432648, .469859957695007, .585271000862122, .664822995662689, .622952997684479, .67722100019455, .655896008014679, .679836988449097, .687132000923157, .677654027938843, .716481983661652, .666799008846283, .758756995201111, .617213010787964, .897013008594513, .531230986118317, .732392013072968, .575452983379364, .70211398601532, .566837012767792, .66652500629425, .566133975982666, .633504986763, .5739120244979861, .603875994682312, .583413004875183, .579657971858978, .590054988861084, .992439985275269, .519222974777222, .567192018032074, .43058001995086703, .54136598110199, .521100997924805, .526564002037048, .453881978988647, .523913025856018, .43616998195648204, .531529009342194, .444943010807037, .566035985946655, .41767096519470204, .51631098985672, .43694603443145796, .5174720287323, .42212295532226596, .573594987392426, .610193014144897, .560697972774506, .604668021202087, .549755990505219, .6002489924430849, .710287988185883, .631747007369995, .723330020904541, .636627018451691];
import *as THREE from "https://cdn.bootcdn.net/ajax/libs/three.js/0.147.0/three.module.min.js";
import {
    AnimationClip,
    Bone,
    Box3,
    BufferAttribute,
    BufferGeometry,
    ClampToEdgeWrapping,
    Color,
    DirectionalLight,
    DoubleSide,
    FileLoader,
    FrontSide,
    Group,
    ImageBitmapLoader,
    InstancedMesh,
    InterleavedBuffer,
    InterleavedBufferAttribute,
    Interpolant,
    InterpolateDiscrete,
    InterpolateLinear,
    Line,
    LineBasicMaterial,
    LineLoop,
    LineSegments,
    LinearFilter,
    LinearMipmapLinearFilter,
    LinearMipmapNearestFilter,
    Loader,
    LoaderUtils,
    Material,
    MathUtils,
    Matrix4,
    Mesh,
    MeshBasicMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MirroredRepeatWrapping,
    NearestFilter,
    NearestMipmapLinearFilter,
    NearestMipmapNearestFilter,
    NumberKeyframeTrack,
    Object3D,
    OrthographicCamera,
    PerspectiveCamera,
    PointLight,
    Points,
    PointsMaterial,
    PropertyBinding,
    Quaternion,
    QuaternionKeyframeTrack,
    RepeatWrapping,
    Skeleton,
    SkinnedMesh,
    Sphere,
    SpotLight,
    Texture,
    TextureLoader,
    TriangleFanDrawMode,
    TriangleStripDrawMode,
    Vector2,
    Vector3,
    VectorKeyframeTrack,
    sRGBEncoding
} from "https://cdn.bootcdn.net/ajax/libs/three.js/0.147.0/three.module.min.js";

class GLTFLoader extends Loader {
    constructor(e) {
        super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (e) {
            return new GLTFMaterialsClearcoatExtension(e)
        }), this.register(function (e) {
            return new GLTFTextureBasisUExtension(e)
        }), this.register(function (e) {
            return new GLTFTextureWebPExtension(e)
        }), this.register(function (e) {
            return new GLTFMaterialsSheenExtension(e)
        }), this.register(function (e) {
            return new GLTFMaterialsTransmissionExtension(e)
        }), this.register(function (e) {
            return new GLTFMaterialsVolumeExtension(e)
        }), this.register(function (e) {
            return new GLTFMaterialsIorExtension(e)
        }), this.register(function (e) {
            return new GLTFMaterialsEmissiveStrengthExtension(e)
        }), this.register(function (e) {
            return new GLTFMaterialsSpecularExtension(e)
        }), this.register(function (e) {
            return new GLTFMaterialsIridescenceExtension(e)
        }), this.register(function (e) {
            return new GLTFLightsExtension(e)
        }), this.register(function (e) {
            return new GLTFMeshoptCompression(e)
        }), this.register(function (e) {
            return new GLTFMeshGpuInstancing(e)
        })
    }

    load(e, t, s, n) {
        const i = this;
        let r;
        r = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : LoaderUtils.extractUrlBase(e), this.manager.itemStart(e);
        const o = function (t) {
            n ? n(t) : console.error(t), i.manager.itemError(e), i.manager.itemEnd(e)
        }, a = new FileLoader(this.manager);
        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (s) {
            try {
                i.parse(s, r, function (s) {
                    t(s), i.manager.itemEnd(e)
                }, o)
            } catch (e) {
                o(e)
            }
        }, s, o)
    }

    setDRACOLoader(e) {
        return this.dracoLoader = e, this
    }

    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }

    setKTX2Loader(e) {
        return this.ktx2Loader = e, this
    }

    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e, this
    }

    register(e) {
        return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
    }

    unregister(e) {
        return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
    }

    parse(e, t, s, n) {
        let i;
        const r = {}, o = {};
        if ("string" == typeof e) i = JSON.parse(e); else if (e instanceof ArrayBuffer) {
            if (LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
                try {
                    r[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(e)
                } catch (e) {
                    return void (n && n(e))
                }
                i = JSON.parse(r[EXTENSIONS.KHR_BINARY_GLTF].content)
            } else i = JSON.parse(LoaderUtils.decodeText(new Uint8Array(e)))
        } else i = e;
        if (void 0 === i.asset || i.asset.version[0] < 2) return void (n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
        const a = new GLTFParser(i, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        a.fileLoader.setRequestHeader(this.requestHeader);
        for (let e = 0; e < this.pluginCallbacks.length; e++) {
            const t = this.pluginCallbacks[e](a);
            o[t.name] = t, r[t.name] = !0
        }
        if (i.extensionsUsed) for (let e = 0; e < i.extensionsUsed.length; ++e) {
            const t = i.extensionsUsed[e], s = i.extensionsRequired || [];
            switch (t) {
                case EXTENSIONS.KHR_MATERIALS_UNLIT:
                    r[t] = new GLTFMaterialsUnlitExtension;
                    break;
                case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                    r[t] = new GLTFDracoMeshCompressionExtension(i, this.dracoLoader);
                    break;
                case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                    r[t] = new GLTFTextureTransformExtension;
                    break;
                case EXTENSIONS.KHR_MESH_QUANTIZATION:
                    r[t] = new GLTFMeshQuantizationExtension;
                    break;
                default:
                    s.indexOf(t) >= 0 && void 0 === o[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
            }
        }
        a.setExtensions(r), a.setPlugins(o), a.parse(s, n)
    }

    parseAsync(e, t) {
        const s = this;
        return new Promise(function (n, i) {
            s.parse(e, t, n, i)
        })
    }
}

function GLTFRegistry() {
    let e = {};
    return {
        get: function (t) {
            return e[t]
        }, add: function (t, s) {
            e[t] = s
        }, remove: function (t) {
            delete e[t]
        }, removeAll: function () {
            e = {}
        }
    }
}

const EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};

class GLTFLightsExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} }
    }

    _markDefs() {
        const e = this.parser, t = this.parser.json.nodes || [];
        for (let s = 0, n = t.length; s < n; s++) {
            const n = t[s];
            n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light)
        }
    }

    _loadLight(e) {
        const t = this.parser, s = "light:" + e;
        let n = t.cache.get(s);
        if (n) return n;
        const i = t.json, r = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
        let o;
        const a = new Color(16777215);
        void 0 !== r.color && a.fromArray(r.color);
        const c = void 0 !== r.range ? r.range : 0;
        switch (r.type) {
            case"directional":
                (o = new DirectionalLight(a)).target.position.set(0, 0, -1), o.add(o.target);
                break;
            case"point":
                (o = new PointLight(a)).distance = c;
                break;
            case"spot":
                (o = new SpotLight(a)).distance = c, r.spot = r.spot || {}, r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0, r.spot.outerConeAngle = void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4, o.angle = r.spot.outerConeAngle, o.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + r.type)
        }
        return o.position.set(0, 0, 0), o.decay = 2, assignExtrasToUserData(o, r), void 0 !== r.intensity && (o.intensity = r.intensity), o.name = t.createUniqueName(r.name || "light_" + e), n = Promise.resolve(o), t.cache.add(s, n), n
    }

    getDependency(e, t) {
        if ("light" === e) return this._loadLight(t)
    }

    createNodeAttachment(e) {
        const t = this, s = this.parser, n = s.json.nodes[e], i = (n.extensions && n.extensions[this.name] || {}).light;
        return void 0 === i ? null : this._loadLight(i).then(function (e) {
            return s._getNodeRef(t.cache, i, e)
        })
    }
}

class GLTFMaterialsUnlitExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT
    }

    getMaterialType() {
        return MeshBasicMaterial
    }

    extendParams(e, t, s) {
        const n = [];
        e.color = new Color(1, 1, 1), e.opacity = 1;
        const i = t.pbrMetallicRoughness;
        if (i) {
            if (Array.isArray(i.baseColorFactor)) {
                const t = i.baseColorFactor;
                e.color.fromArray(t), e.opacity = t[3]
            }
            void 0 !== i.baseColorTexture && n.push(s.assignTexture(e, "map", i.baseColorTexture, sRGBEncoding))
        }
        return Promise.all(n)
    }
}

class GLTFMaterialsEmissiveStrengthExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH
    }

    extendMaterialParams(e, t) {
        const s = this.parser.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const n = s.extensions[this.name].emissiveStrength;
        return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve()
    }
}

class GLTFMaterialsClearcoatExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT
    }

    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null
    }

    extendMaterialParams(e, t) {
        const s = this.parser, n = s.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = [], r = n.extensions[this.name];
        if (void 0 !== r.clearcoatFactor && (t.clearcoat = r.clearcoatFactor), void 0 !== r.clearcoatTexture && i.push(s.assignTexture(t, "clearcoatMap", r.clearcoatTexture)), void 0 !== r.clearcoatRoughnessFactor && (t.clearcoatRoughness = r.clearcoatRoughnessFactor), void 0 !== r.clearcoatRoughnessTexture && i.push(s.assignTexture(t, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), void 0 !== r.clearcoatNormalTexture && (i.push(s.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)), void 0 !== r.clearcoatNormalTexture.scale)) {
            const e = r.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Vector2(e, e)
        }
        return Promise.all(i)
    }
}

class GLTFMaterialsIridescenceExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE
    }

    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null
    }

    extendMaterialParams(e, t) {
        const s = this.parser, n = s.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = [], r = n.extensions[this.name];
        return void 0 !== r.iridescenceFactor && (t.iridescence = r.iridescenceFactor), void 0 !== r.iridescenceTexture && i.push(s.assignTexture(t, "iridescenceMap", r.iridescenceTexture)), void 0 !== r.iridescenceIor && (t.iridescenceIOR = r.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== r.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), void 0 !== r.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), void 0 !== r.iridescenceThicknessTexture && i.push(s.assignTexture(t, "iridescenceThicknessMap", r.iridescenceThicknessTexture)), Promise.all(i)
    }
}

class GLTFMaterialsSheenExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_SHEEN
    }

    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null
    }

    extendMaterialParams(e, t) {
        const s = this.parser, n = s.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = [];
        t.sheenColor = new Color(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
        const r = n.extensions[this.name];
        return void 0 !== r.sheenColorFactor && t.sheenColor.fromArray(r.sheenColorFactor), void 0 !== r.sheenRoughnessFactor && (t.sheenRoughness = r.sheenRoughnessFactor), void 0 !== r.sheenColorTexture && i.push(s.assignTexture(t, "sheenColorMap", r.sheenColorTexture, sRGBEncoding)), void 0 !== r.sheenRoughnessTexture && i.push(s.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(i)
    }
}

class GLTFMaterialsTransmissionExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION
    }

    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null
    }

    extendMaterialParams(e, t) {
        const s = this.parser, n = s.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = [], r = n.extensions[this.name];
        return void 0 !== r.transmissionFactor && (t.transmission = r.transmissionFactor), void 0 !== r.transmissionTexture && i.push(s.assignTexture(t, "transmissionMap", r.transmissionTexture)), Promise.all(i)
    }
}

class GLTFMaterialsVolumeExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_VOLUME
    }

    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null
    }

    extendMaterialParams(e, t) {
        const s = this.parser, n = s.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = [], r = n.extensions[this.name];
        t.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0, void 0 !== r.thicknessTexture && i.push(s.assignTexture(t, "thicknessMap", r.thicknessTexture)), t.attenuationDistance = r.attenuationDistance || 1 / 0;
        const o = r.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new Color(o[0], o[1], o[2]), Promise.all(i)
    }
}

class GLTFMaterialsIorExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_IOR
    }

    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null
    }

    extendMaterialParams(e, t) {
        const s = this.parser.json.materials[e];
        if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
        const n = s.extensions[this.name];
        return t.ior = void 0 !== n.ior ? n.ior : 1.5, Promise.resolve()
    }
}

class GLTFMaterialsSpecularExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR
    }

    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null
    }

    extendMaterialParams(e, t) {
        const s = this.parser, n = s.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const i = [], r = n.extensions[this.name];
        t.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1, void 0 !== r.specularTexture && i.push(s.assignTexture(t, "specularIntensityMap", r.specularTexture));
        const o = r.specularColorFactor || [1, 1, 1];
        return t.specularColor = new Color(o[0], o[1], o[2]), void 0 !== r.specularColorTexture && i.push(s.assignTexture(t, "specularColorMap", r.specularColorTexture, sRGBEncoding)), Promise.all(i)
    }
}

class GLTFTextureBasisUExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.KHR_TEXTURE_BASISU
    }

    loadTexture(e) {
        const t = this.parser, s = t.json, n = s.textures[e];
        if (!n.extensions || !n.extensions[this.name]) return null;
        const i = n.extensions[this.name], r = t.options.ktx2Loader;
        if (!r) {
            if (s.extensionsRequired && s.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, i.source, r)
    }
}

class GLTFTextureWebPExtension {
    constructor(e) {
        this.parser = e, this.name = EXTENSIONS.EXT_TEXTURE_WEBP, this.isSupported = null
    }

    loadTexture(e) {
        const t = this.name, s = this.parser, n = s.json, i = n.textures[e];
        if (!i.extensions || !i.extensions[t]) return null;
        const r = i.extensions[t], o = n.images[r.source];
        let a = s.textureLoader;
        if (o.uri) {
            const e = s.options.manager.getHandler(o.uri);
            null !== e && (a = e)
        }
        return this.detectSupport().then(function (i) {
            if (i) return s.loadTextureImage(e, r.source, a);
            if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return s.loadTexture(e)
        })
    }

    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function (e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
                e(1 === t.height)
            }
        })), this.isSupported
    }
}

class GLTFMeshoptCompression {
    constructor(e) {
        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = e
    }

    loadBufferView(e) {
        const t = this.parser.json, s = t.bufferViews[e];
        if (s.extensions && s.extensions[this.name]) {
            const e = s.extensions[this.name], n = this.parser.getDependency("buffer", e.buffer),
                i = this.parser.options.meshoptDecoder;
            if (!i || !i.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return n.then(function (t) {
                const s = e.byteOffset || 0, n = e.byteLength || 0, r = e.count, o = e.byteStride,
                    a = new Uint8Array(t, s, n);
                return i.decodeGltfBufferAsync ? i.decodeGltfBufferAsync(r, o, a, e.mode, e.filter).then(function (e) {
                    return e.buffer
                }) : i.ready.then(function () {
                    const t = new ArrayBuffer(r * o);
                    return i.decodeGltfBuffer(new Uint8Array(t), r, o, a, e.mode, e.filter), t
                })
            })
        }
        return null
    }
}

class GLTFMeshGpuInstancing {
    constructor(e) {
        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING, this.parser = e
    }

    createNodeMesh(e) {
        const t = this.parser.json, s = t.nodes[e];
        if (!s.extensions || !s.extensions[this.name] || void 0 === s.mesh) return null;
        const n = t.meshes[s.mesh];
        for (const e of n.primitives) if (e.mode !== WEBGL_CONSTANTS.TRIANGLES && e.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && e.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && void 0 !== e.mode) return null;
        const i = s.extensions[this.name].attributes, r = [], o = {};
        for (const e in i) r.push(this.parser.getDependency("accessor", i[e]).then(t => (o[e] = t, o[e])));
        return r.length < 1 ? null : (r.push(this.parser.createNodeMesh(e)), Promise.all(r).then(e => {
            const t = e.pop(), s = t.isGroup ? t.children : [t], n = e[0].count, i = [];
            for (const e of s) {
                const t = new Matrix4, s = new Vector3, r = new Quaternion, a = new Vector3(1, 1, 1),
                    c = new InstancedMesh(e.geometry, e.material, n);
                for (let e = 0; e < n; e++) o.TRANSLATION && s.fromBufferAttribute(o.TRANSLATION, e), o.ROTATION && r.fromBufferAttribute(o.ROTATION, e), o.SCALE && a.fromBufferAttribute(o.SCALE, e), c.setMatrixAt(e, t.compose(s, r, a));
                for (const t in o) "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, o[t]);
                Object3D.prototype.copy.call(c, e), c.frustumCulled = !1, this.parser.assignFinalMaterial(c), i.push(c)
            }
            return t.isGroup ? (t.clear(), t.add(...i), t) : i[0]
        }))
    }
}

const BINARY_EXTENSION_HEADER_MAGIC = "glTF", BINARY_EXTENSION_HEADER_LENGTH = 12,
    BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };

class GLTFBinaryExtension {
    constructor(e) {
        this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const t = new DataView(e, 0, BINARY_EXTENSION_HEADER_LENGTH);
        if (this.header = {
            magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        }, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const s = this.header.length - BINARY_EXTENSION_HEADER_LENGTH,
            n = new DataView(e, BINARY_EXTENSION_HEADER_LENGTH);
        let i = 0;
        for (; i < s;) {
            const t = n.getUint32(i, !0);
            i += 4;
            const s = n.getUint32(i, !0);
            if (i += 4, s === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
                const s = new Uint8Array(e, BINARY_EXTENSION_HEADER_LENGTH + i, t);
                this.content = LoaderUtils.decodeText(s)
            } else if (s === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
                const s = BINARY_EXTENSION_HEADER_LENGTH + i;
                this.body = e.slice(s, s + t)
            }
            i += t
        }
        if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}

class GLTFDracoMeshCompressionExtension {
    constructor(e, t) {
        if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
    }

    decodePrimitive(e, t) {
        const s = this.json, n = this.dracoLoader, i = e.extensions[this.name].bufferView,
            r = e.extensions[this.name].attributes, o = {}, a = {}, c = {};
        for (const e in r) {
            const t = ATTRIBUTES[e] || e.toLowerCase();
            o[t] = r[e]
        }
        for (const t in e.attributes) {
            const n = ATTRIBUTES[t] || t.toLowerCase();
            if (void 0 !== r[t]) {
                const i = s.accessors[e.attributes[t]], r = WEBGL_COMPONENT_TYPES[i.componentType];
                c[n] = r.name, a[n] = !0 === i.normalized
            }
        }
        return t.getDependency("bufferView", i).then(function (e) {
            return new Promise(function (t) {
                n.decodeDracoFile(e, function (e) {
                    for (const t in e.attributes) {
                        const s = e.attributes[t], n = a[t];
                        void 0 !== n && (s.normalized = n)
                    }
                    t(e)
                }, o, c)
            })
        })
    }
}

class GLTFTextureTransformExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM
    }

    extendTexture(e, t) {
        return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale ? e : (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e)
    }
}

class GLTFMeshQuantizationExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION
    }
}

class GLTFCubicSplineInterpolant extends Interpolant {
    constructor(e, t, s, n) {
        super(e, t, s, n)
    }

    copySampleValue_(e) {
        const t = this.resultBuffer, s = this.sampleValues, n = this.valueSize, i = e * n * 3 + n;
        for (let e = 0; e !== n; e++) t[e] = s[i + e];
        return t
    }

    interpolate_(e, t, s, n) {
        const i = this.resultBuffer, r = this.sampleValues, o = this.valueSize, a = 2 * o, c = 3 * o, l = n - t,
            h = (s - t) / l, d = h * h, u = d * h, m = e * c, p = m - c, T = -2 * u + 3 * d, f = u - d, g = 1 - T,
            E = f - d + h;
        for (let e = 0; e !== o; e++) {
            const t = r[p + e + o], s = r[p + e + a] * l, n = r[m + e + o], c = r[m + e] * l;
            i[e] = g * t + E * s + T * n + f * c
        }
        return i
    }
}

const _q = new Quaternion;

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
    interpolate_(e, t, s, n) {
        const i = super.interpolate_(e, t, s, n);
        return _q.fromArray(i).normalize().toArray(i), i
    }
}

const WEBGL_CONSTANTS = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    }, WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    }, WEBGL_FILTERS = {
        9728: NearestFilter,
        9729: LinearFilter,
        9984: NearestMipmapNearestFilter,
        9985: LinearMipmapNearestFilter,
        9986: NearestMipmapLinearFilter,
        9987: LinearMipmapLinearFilter
    }, WEBGL_WRAPPINGS = { 33071: ClampToEdgeWrapping, 33648: MirroredRepeatWrapping, 10497: RepeatWrapping },
    WEBGL_TYPE_SIZES = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, ATTRIBUTES = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv2",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    }, PATH_PROPERTIES = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    }, INTERPOLATION = { CUBICSPLINE: void 0, LINEAR: InterpolateLinear, STEP: InterpolateDiscrete },
    ALPHA_MODES = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };

function createDefaultMaterial(e) {
    return void 0 === e.DefaultMaterial && (e.DefaultMaterial = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: FrontSide
    })), e.DefaultMaterial
}

function addUnknownExtensionsToUserData(e, t, s) {
    for (const n in s.extensions) void 0 === e[n] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = s.extensions[n])
}

function assignExtrasToUserData(e, t) {
    void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
}

function addMorphTargets(e, t, s) {
    let n = !1, i = !1, r = !1;
    for (let e = 0, s = t.length; e < s; e++) {
        const s = t[e];
        if (void 0 !== s.POSITION && (n = !0), void 0 !== s.NORMAL && (i = !0), void 0 !== s.COLOR_0 && (r = !0), n && i && r) break
    }
    if (!n && !i && !r) return Promise.resolve(e);
    const o = [], a = [], c = [];
    for (let l = 0, h = t.length; l < h; l++) {
        const h = t[l];
        if (n) {
            const t = void 0 !== h.POSITION ? s.getDependency("accessor", h.POSITION) : e.attributes.position;
            o.push(t)
        }
        if (i) {
            const t = void 0 !== h.NORMAL ? s.getDependency("accessor", h.NORMAL) : e.attributes.normal;
            a.push(t)
        }
        if (r) {
            const t = void 0 !== h.COLOR_0 ? s.getDependency("accessor", h.COLOR_0) : e.attributes.color;
            c.push(t)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(c)]).then(function (t) {
        const s = t[0], o = t[1], a = t[2];
        return n && (e.morphAttributes.position = s), i && (e.morphAttributes.normal = o), r && (e.morphAttributes.color = a), e.morphTargetsRelative = !0, e
    })
}

function updateMorphTargets(e, t) {
    if (e.updateMorphTargets(), void 0 !== t.weights) for (let s = 0, n = t.weights.length; s < n; s++) e.morphTargetInfluences[s] = t.weights[s];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
        const s = t.extras.targetNames;
        if (e.morphTargetInfluences.length === s.length) {
            e.morphTargetDictionary = {};
            for (let t = 0, n = s.length; t < n; t++) e.morphTargetDictionary[s[t]] = t
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}

function createPrimitiveKey(e) {
    const t = e.extensions && e.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    let s;
    return s = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + createAttributesKey(t.attributes) : e.indices + ":" + createAttributesKey(e.attributes) + ":" + e.mode
}

function createAttributesKey(e) {
    let t = "";
    const s = Object.keys(e).sort();
    for (let n = 0, i = s.length; n < i; n++) t += s[n] + ":" + e[s[n]] + ";";
    return t
}

function getNormalizedComponentScale(e) {
    switch (e) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}

function getImageURIMimeType(e) {
    return e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/) ? "image/jpeg" : e.search(/\.webp($|\?)/i) > 0 || 0 === e.search(/^data\:image\/webp/) ? "image/webp" : "image/png"
}

class GLTFParser {
    constructor(e = {}, t = {}) {
        this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new GLTFRegistry, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        let s = !1, n = !1, i = -1;
        "undefined" != typeof navigator && (s = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i = (n = navigator.userAgent.indexOf("Firefox") > -1) ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || s || n && i < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
    }

    setExtensions(e) {
        this.extensions = e
    }

    setPlugins(e) {
        this.plugins = e
    }

    parse(e, t) {
        const s = this, n = this.json, i = this.extensions;
        this.cache.removeAll(), this._invokeAll(function (e) {
            return e._markDefs && e._markDefs()
        }), Promise.all(this._invokeAll(function (e) {
            return e.beforeRoot && e.beforeRoot()
        })).then(function () {
            return Promise.all([s.getDependencies("scene"), s.getDependencies("animation"), s.getDependencies("camera")])
        }).then(function (t) {
            const r = {
                scene: t[0][n.scene || 0],
                scenes: t[0],
                animations: t[1],
                cameras: t[2],
                asset: n.asset,
                parser: s,
                userData: {}
            };
            addUnknownExtensionsToUserData(i, r, n), assignExtrasToUserData(r, n), Promise.all(s._invokeAll(function (e) {
                return e.afterRoot && e.afterRoot(r)
            })).then(function () {
                e(r)
            })
        }).catch(t)
    }

    _markDefs() {
        const e = this.json.nodes || [], t = this.json.skins || [], s = this.json.meshes || [];
        for (let s = 0, n = t.length; s < n; s++) {
            const n = t[s].joints;
            for (let t = 0, s = n.length; t < s; t++) e[n[t]].isBone = !0
        }
        for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.skin && (s[n.mesh].isSkinnedMesh = !0)), void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera)
        }
    }

    _addNodeRef(e, t) {
        void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
    }

    _getNodeRef(e, t, s) {
        if (e.refs[t] <= 1) return s;
        const n = s.clone(), i = (e, t) => {
            const s = this.associations.get(e);
            null != s && this.associations.set(t, s);
            for (const [s, n] of e.children.entries()) i(n, t.children[s])
        };
        return i(s, n), n.name += "_instance_" + e.uses[t]++, n
    }

    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let s = 0; s < t.length; s++) {
            const n = e(t[s]);
            if (n) return n
        }
        return null
    }

    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const s = [];
        for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            i && s.push(i)
        }
        return s
    }

    getDependency(e, t) {
        const s = e + ":" + t;
        let n = this.cache.get(s);
        if (!n) {
            switch (e) {
                case"scene":
                    n = this.loadScene(t);
                    break;
                case"node":
                    n = this.loadNode(t);
                    break;
                case"mesh":
                    n = this._invokeOne(function (e) {
                        return e.loadMesh && e.loadMesh(t)
                    });
                    break;
                case"accessor":
                    n = this.loadAccessor(t);
                    break;
                case"bufferView":
                    n = this._invokeOne(function (e) {
                        return e.loadBufferView && e.loadBufferView(t)
                    });
                    break;
                case"buffer":
                    n = this.loadBuffer(t);
                    break;
                case"material":
                    n = this._invokeOne(function (e) {
                        return e.loadMaterial && e.loadMaterial(t)
                    });
                    break;
                case"texture":
                    n = this._invokeOne(function (e) {
                        return e.loadTexture && e.loadTexture(t)
                    });
                    break;
                case"skin":
                    n = this.loadSkin(t);
                    break;
                case"animation":
                    n = this._invokeOne(function (e) {
                        return e.loadAnimation && e.loadAnimation(t)
                    });
                    break;
                case"camera":
                    n = this.loadCamera(t);
                    break;
                default:
                    if (!(n = this._invokeOne(function (s) {
                        return s != this && s.getDependency && s.getDependency(e, t)
                    }))) throw new Error("Unknown type: " + e)
            }
            this.cache.add(s, n)
        }
        return n
    }

    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const s = this, n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
            t = Promise.all(n.map(function (t, n) {
                return s.getDependency(e, n)
            })), this.cache.add(e, t)
        }
        return t
    }

    loadBuffer(e) {
        const t = this.json.buffers[e], s = this.fileLoader;
        if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
        const n = this.options;
        return new Promise(function (e, i) {
            s.load(LoaderUtils.resolveURL(t.uri, n.path), e, void 0, function () {
                i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        })
    }

    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function (e) {
            const s = t.byteLength || 0, n = t.byteOffset || 0;
            return e.slice(n, n + s)
        })
    }

    loadAccessor(e) {
        const t = this, s = this.json, n = this.json.accessors[e];
        if (void 0 === n.bufferView && void 0 === n.sparse) {
            const e = WEBGL_TYPE_SIZES[n.type], t = WEBGL_COMPONENT_TYPES[n.componentType], s = !0 === n.normalized,
                i = new t(n.count * e);
            return Promise.resolve(new BufferAttribute(i, e, s))
        }
        const i = [];
        return void 0 !== n.bufferView ? i.push(this.getDependency("bufferView", n.bufferView)) : i.push(null), void 0 !== n.sparse && (i.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(i).then(function (e) {
            const i = e[0], r = WEBGL_TYPE_SIZES[n.type], o = WEBGL_COMPONENT_TYPES[n.componentType],
                a = o.BYTES_PER_ELEMENT, c = a * r, l = n.byteOffset || 0,
                h = void 0 !== n.bufferView ? s.bufferViews[n.bufferView].byteStride : void 0, d = !0 === n.normalized;
            let u, m;
            if (h && h !== c) {
                const e = Math.floor(l / h),
                    s = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + e + ":" + n.count;
                let c = t.cache.get(s);
                c || (u = new o(i, e * h, n.count * h / a), c = new InterleavedBuffer(u, h / a), t.cache.add(s, c)), m = new InterleavedBufferAttribute(c, r, l % h / a, d)
            } else u = null === i ? new o(n.count * r) : new o(i, l, n.count * r), m = new BufferAttribute(u, r, d);
            if (void 0 !== n.sparse) {
                const t = WEBGL_TYPE_SIZES.SCALAR, s = WEBGL_COMPONENT_TYPES[n.sparse.indices.componentType],
                    a = n.sparse.indices.byteOffset || 0, c = n.sparse.values.byteOffset || 0,
                    l = new s(e[1], a, n.sparse.count * t), h = new o(e[2], c, n.sparse.count * r);
                null !== i && (m = new BufferAttribute(m.array.slice(), m.itemSize, m.normalized));
                for (let e = 0, t = l.length; e < t; e++) {
                    const t = l[e];
                    if (m.setX(t, h[e * r]), r >= 2 && m.setY(t, h[e * r + 1]), r >= 3 && m.setZ(t, h[e * r + 2]), r >= 4 && m.setW(t, h[e * r + 3]), r >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return m
        })
    }

    loadTexture(e) {
        const t = this.json, s = this.options, n = t.textures[e].source, i = t.images[n];
        let r = this.textureLoader;
        if (i.uri) {
            const e = s.manager.getHandler(i.uri);
            null !== e && (r = e)
        }
        return this.loadTextureImage(e, n, r)
    }

    loadTextureImage(e, t, s) {
        const n = this, i = this.json, r = i.textures[e], o = i.images[t],
            a = (o.uri || o.bufferView) + ":" + r.sampler;
        if (this.textureCache[a]) return this.textureCache[a];
        const c = this.loadImageSource(t, s).then(function (t) {
            t.flipY = !1, t.name = r.name || o.name || "";
            const s = (i.samplers || {})[r.sampler] || {};
            return t.magFilter = WEBGL_FILTERS[s.magFilter] || LinearFilter, t.minFilter = WEBGL_FILTERS[s.minFilter] || LinearMipmapLinearFilter, t.wrapS = WEBGL_WRAPPINGS[s.wrapS] || RepeatWrapping, t.wrapT = WEBGL_WRAPPINGS[s.wrapT] || RepeatWrapping, n.associations.set(t, { textures: e }), t
        }).catch(function () {
            return null
        });
        return this.textureCache[a] = c, c
    }

    loadImageSource(e, t) {
        const s = this, n = this.json, i = this.options;
        if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then(e => e.clone());
        const r = n.images[e], o = self.URL || self.webkitURL;
        let a = r.uri || "", c = !1;
        if (void 0 !== r.bufferView) a = s.getDependency("bufferView", r.bufferView).then(function (e) {
            c = !0;
            const t = new Blob([e], { type: r.mimeType });
            return a = o.createObjectURL(t)
        }); else if (void 0 === r.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const l = Promise.resolve(a).then(function (e) {
            return new Promise(function (s, n) {
                let r = s;
                !0 === t.isImageBitmapLoader && (r = function (e) {
                    const t = new Texture(e);
                    t.needsUpdate = !0, s(t)
                }), t.load(LoaderUtils.resolveURL(e, i.path), r, void 0, n)
            })
        }).then(function (e) {
            return !0 === c && o.revokeObjectURL(a), e.userData.mimeType = r.mimeType || getImageURIMimeType(r.uri), e
        }).catch(function (e) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", a), e
        });
        return this.sourceCache[e] = l, l
    }

    assignTexture(e, t, s, n) {
        const i = this;
        return this.getDependency("texture", s.index).then(function (r) {
            if (!r) return null;
            if (void 0 === s.texCoord || 0 == s.texCoord || "aoMap" === t && 1 == s.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + s.texCoord + " for texture " + t + " not yet supported."), i.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
                const e = void 0 !== s.extensions ? s.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
                if (e) {
                    const t = i.associations.get(r);
                    r = i.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(r, e), i.associations.set(r, t)
                }
            }
            return void 0 !== n && (r.encoding = n), e[t] = r, r
        })
    }

    assignFinalMaterial(e) {
        const t = e.geometry;
        let s = e.material;
        const n = void 0 === t.attributes.tangent, i = void 0 !== t.attributes.color,
            r = void 0 === t.attributes.normal;
        if (e.isPoints) {
            const e = "PointsMaterial:" + s.uuid;
            let t = this.cache.get(e);
            t || (t = new PointsMaterial, Material.prototype.copy.call(t, s), t.color.copy(s.color), t.map = s.map, t.sizeAttenuation = !1, this.cache.add(e, t)), s = t
        } else if (e.isLine) {
            const e = "LineBasicMaterial:" + s.uuid;
            let t = this.cache.get(e);
            t || (t = new LineBasicMaterial, Material.prototype.copy.call(t, s), t.color.copy(s.color), this.cache.add(e, t)), s = t
        }
        if (n || i || r) {
            let e = "ClonedMaterial:" + s.uuid + ":";
            n && (e += "derivative-tangents:"), i && (e += "vertex-colors:"), r && (e += "flat-shading:");
            let t = this.cache.get(e);
            t || (t = s.clone(), i && (t.vertexColors = !0), r && (t.flatShading = !0), n && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(s))), s = t
        }
        s.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = s
    }

    getMaterialType() {
        return MeshStandardMaterial
    }

    loadMaterial(e) {
        const t = this, s = this.json, n = this.extensions, i = s.materials[e];
        let r;
        const o = {}, a = [];
        if ((i.extensions || {})[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
            const e = n[EXTENSIONS.KHR_MATERIALS_UNLIT];
            r = e.getMaterialType(), a.push(e.extendParams(o, i, t))
        } else {
            const s = i.pbrMetallicRoughness || {};
            if (o.color = new Color(1, 1, 1), o.opacity = 1, Array.isArray(s.baseColorFactor)) {
                const e = s.baseColorFactor;
                o.color.fromArray(e), o.opacity = e[3]
            }
            void 0 !== s.baseColorTexture && a.push(t.assignTexture(o, "map", s.baseColorTexture, sRGBEncoding)), o.metalness = void 0 !== s.metallicFactor ? s.metallicFactor : 1, o.roughness = void 0 !== s.roughnessFactor ? s.roughnessFactor : 1, void 0 !== s.metallicRoughnessTexture && (a.push(t.assignTexture(o, "metalnessMap", s.metallicRoughnessTexture)), a.push(t.assignTexture(o, "roughnessMap", s.metallicRoughnessTexture))), r = this._invokeOne(function (t) {
                return t.getMaterialType && t.getMaterialType(e)
            }), a.push(Promise.all(this._invokeAll(function (t) {
                return t.extendMaterialParams && t.extendMaterialParams(e, o)
            })))
        }
        !0 === i.doubleSided && (o.side = DoubleSide);
        const c = i.alphaMode || ALPHA_MODES.OPAQUE;
        if (c === ALPHA_MODES.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, c === ALPHA_MODES.MASK && (o.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : .5)), void 0 !== i.normalTexture && r !== MeshBasicMaterial && (a.push(t.assignTexture(o, "normalMap", i.normalTexture)), o.normalScale = new Vector2(1, 1), void 0 !== i.normalTexture.scale)) {
            const e = i.normalTexture.scale;
            o.normalScale.set(e, e)
        }
        return void 0 !== i.occlusionTexture && r !== MeshBasicMaterial && (a.push(t.assignTexture(o, "aoMap", i.occlusionTexture)), void 0 !== i.occlusionTexture.strength && (o.aoMapIntensity = i.occlusionTexture.strength)), void 0 !== i.emissiveFactor && r !== MeshBasicMaterial && (o.emissive = (new Color).fromArray(i.emissiveFactor)), void 0 !== i.emissiveTexture && r !== MeshBasicMaterial && a.push(t.assignTexture(o, "emissiveMap", i.emissiveTexture, sRGBEncoding)), Promise.all(a).then(function () {
            const s = new r(o);
            return i.name && (s.name = i.name), assignExtrasToUserData(s, i), t.associations.set(s, { materials: e }), i.extensions && addUnknownExtensionsToUserData(n, s, i), s
        })
    }

    createUniqueName(e) {
        const t = PropertyBinding.sanitizeNodeName(e || "");
        let s = t;
        for (let e = 1; this.nodeNamesUsed[s]; ++e) s = t + "_" + e;
        return this.nodeNamesUsed[s] = !0, s
    }

    loadGeometries(e) {
        const t = this, s = this.extensions, n = this.primitiveCache;

        function i(e) {
            return s[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then(function (s) {
                return addPrimitiveAttributes(s, e, t)
            })
        }

        const r = [];
        for (let s = 0, o = e.length; s < o; s++) {
            const o = e[s], a = createPrimitiveKey(o), c = n[a];
            if (c) r.push(c.promise); else {
                let e;
                e = o.extensions && o.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? i(o) : addPrimitiveAttributes(new BufferGeometry, o, t), n[a] = {
                    primitive: o,
                    promise: e
                }, r.push(e)
            }
        }
        return Promise.all(r)
    }

    loadMesh(e) {
        const t = this, s = this.json, n = this.extensions, i = s.meshes[e], r = i.primitives, o = [];
        for (let e = 0, t = r.length; e < t; e++) {
            const t = void 0 === r[e].material ? createDefaultMaterial(this.cache) : this.getDependency("material", r[e].material);
            o.push(t)
        }
        return o.push(t.loadGeometries(r)), Promise.all(o).then(function (s) {
            const o = s.slice(0, s.length - 1), a = s[s.length - 1], c = [];
            for (let s = 0, l = a.length; s < l; s++) {
                const l = a[s], h = r[s];
                let d;
                const u = o[s];
                if (h.mode === WEBGL_CONSTANTS.TRIANGLES || h.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || h.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || void 0 === h.mode) !0 !== (d = !0 === i.isSkinnedMesh ? new SkinnedMesh(l, u) : new Mesh(l, u)).isSkinnedMesh || d.geometry.attributes.skinWeight.normalized || d.normalizeSkinWeights(), h.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? d.geometry = toTrianglesDrawMode(d.geometry, TriangleStripDrawMode) : h.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (d.geometry = toTrianglesDrawMode(d.geometry, TriangleFanDrawMode)); else if (h.mode === WEBGL_CONSTANTS.LINES) d = new LineSegments(l, u); else if (h.mode === WEBGL_CONSTANTS.LINE_STRIP) d = new Line(l, u); else if (h.mode === WEBGL_CONSTANTS.LINE_LOOP) d = new LineLoop(l, u); else {
                    if (h.mode !== WEBGL_CONSTANTS.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                    d = new Points(l, u)
                }
                Object.keys(d.geometry.morphAttributes).length > 0 && updateMorphTargets(d, i), d.name = t.createUniqueName(i.name || "mesh_" + e), assignExtrasToUserData(d, i), h.extensions && addUnknownExtensionsToUserData(n, d, h), t.assignFinalMaterial(d), c.push(d)
            }
            for (let s = 0, n = c.length; s < n; s++) t.associations.set(c[s], { meshes: e, primitives: s });
            if (1 === c.length) return c[0];
            const l = new Group;
            t.associations.set(l, { meshes: e });
            for (let e = 0, t = c.length; e < t; e++) l.add(c[e]);
            return l
        })
    }

    loadCamera(e) {
        let t;
        const s = this.json.cameras[e], n = s[s.type];
        if (n) return "perspective" === s.type ? t = new PerspectiveCamera(MathUtils.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : "orthographic" === s.type && (t = new OrthographicCamera(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), s.name && (t.name = this.createUniqueName(s.name)), assignExtrasToUserData(t, s), Promise.resolve(t);
        console.warn("THREE.GLTFLoader: Missing camera parameters.")
    }

    loadSkin(e) {
        const t = this.json.skins[e], s = [];
        for (let e = 0, n = t.joints.length; e < n; e++) s.push(this.getDependency("node", t.joints[e]));
        return void 0 !== t.inverseBindMatrices ? s.push(this.getDependency("accessor", t.inverseBindMatrices)) : s.push(null), Promise.all(s).then(function (e) {
            const s = e.pop(), n = e, i = [], r = [];
            for (let e = 0, o = n.length; e < o; e++) {
                const o = n[e];
                if (o) {
                    i.push(o);
                    const t = new Matrix4;
                    null !== s && t.fromArray(s.array, 16 * e), r.push(t)
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
            }
            return new Skeleton(i, r)
        })
    }

    loadAnimation(e) {
        const t = this.json.animations[e], s = [], n = [], i = [], r = [], o = [];
        for (let e = 0, a = t.channels.length; e < a; e++) {
            const a = t.channels[e], c = t.samplers[a.sampler], l = a.target, h = l.node,
                d = void 0 !== t.parameters ? t.parameters[c.input] : c.input,
                u = void 0 !== t.parameters ? t.parameters[c.output] : c.output;
            s.push(this.getDependency("node", h)), n.push(this.getDependency("accessor", d)), i.push(this.getDependency("accessor", u)), r.push(c), o.push(l)
        }
        return Promise.all([Promise.all(s), Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(o)]).then(function (s) {
            const n = s[0], i = s[1], r = s[2], o = s[3], a = s[4], c = [];
            for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e], s = i[e], l = r[e], h = o[e], d = a[e];
                if (void 0 === t) continue;
                let u;
                switch (t.updateMatrix(), PATH_PROPERTIES[d.path]) {
                    case PATH_PROPERTIES.weights:
                        u = NumberKeyframeTrack;
                        break;
                    case PATH_PROPERTIES.rotation:
                        u = QuaternionKeyframeTrack;
                        break;
                    case PATH_PROPERTIES.position:
                    case PATH_PROPERTIES.scale:
                    default:
                        u = VectorKeyframeTrack
                }
                const m = t.name ? t.name : t.uuid,
                    p = void 0 !== h.interpolation ? INTERPOLATION[h.interpolation] : InterpolateLinear, T = [];
                PATH_PROPERTIES[d.path] === PATH_PROPERTIES.weights ? t.traverse(function (e) {
                    e.morphTargetInfluences && T.push(e.name ? e.name : e.uuid)
                }) : T.push(m);
                let f = l.array;
                if (l.normalized) {
                    const e = getNormalizedComponentScale(f.constructor), t = new Float32Array(f.length);
                    for (let s = 0, n = f.length; s < n; s++) t[s] = f[s] * e;
                    f = t
                }
                for (let e = 0, t = T.length; e < t; e++) {
                    const t = new u(T[e] + "." + PATH_PROPERTIES[d.path], s.array, f, p);
                    "CUBICSPLINE" === h.interpolation && (t.createInterpolant = function (e) {
                        return new (this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant)(this.times, this.values, this.getValueSize() / 3, e)
                    }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), c.push(t)
                }
            }
            const l = t.name ? t.name : "animation_" + e;
            return new AnimationClip(l, void 0, c)
        })
    }

    createNodeMesh(e) {
        const t = this.json, s = this, n = t.nodes[e];
        return void 0 === n.mesh ? null : s.getDependency("mesh", n.mesh).then(function (e) {
            const t = s._getNodeRef(s.meshCache, n.mesh, e);
            return void 0 !== n.weights && t.traverse(function (e) {
                if (e.isMesh) for (let t = 0, s = n.weights.length; t < s; t++) e.morphTargetInfluences[t] = n.weights[t]
            }), t
        })
    }

    loadNode(e) {
        const t = this.json, s = this.extensions, n = this, i = t.nodes[e],
            r = i.name ? n.createUniqueName(i.name) : "";
        return function () {
            const t = [], s = n._invokeOne(function (t) {
                return t.createNodeMesh && t.createNodeMesh(e)
            });
            return s && t.push(s), void 0 !== i.camera && t.push(n.getDependency("camera", i.camera).then(function (e) {
                return n._getNodeRef(n.cameraCache, i.camera, e)
            })), n._invokeAll(function (t) {
                return t.createNodeAttachment && t.createNodeAttachment(e)
            }).forEach(function (e) {
                t.push(e)
            }), Promise.all(t)
        }().then(function (t) {
            let o;
            if ((o = !0 === i.isBone ? new Bone : t.length > 1 ? new Group : 1 === t.length ? t[0] : new Object3D) !== t[0]) for (let e = 0, s = t.length; e < s; e++) o.add(t[e]);
            if (i.name && (o.userData.name = i.name, o.name = r), assignExtrasToUserData(o, i), i.extensions && addUnknownExtensionsToUserData(s, o, i), void 0 !== i.matrix) {
                const e = new Matrix4;
                e.fromArray(i.matrix), o.applyMatrix4(e)
            } else void 0 !== i.translation && o.position.fromArray(i.translation), void 0 !== i.rotation && o.quaternion.fromArray(i.rotation), void 0 !== i.scale && o.scale.fromArray(i.scale);
            return n.associations.has(o) || n.associations.set(o, {}), n.associations.get(o).nodes = e, o
        })
    }

    loadScene(e) {
        const t = this.json, s = this.extensions, n = this.json.scenes[e], i = this, r = new Group;
        n.name && (r.name = i.createUniqueName(n.name)), assignExtrasToUserData(r, n), n.extensions && addUnknownExtensionsToUserData(s, r, n);
        const o = n.nodes || [], a = [];
        for (let e = 0, s = o.length; e < s; e++) a.push(buildNodeHierarchy(o[e], r, t, i));
        return Promise.all(a).then(function () {
            return i.associations = (e => {
                const t = new Map;
                for (const [e, s] of i.associations) (e instanceof Material || e instanceof Texture) && t.set(e, s);
                return e.traverse(e => {
                    const s = i.associations.get(e);
                    null != s && t.set(e, s)
                }), t
            })(r), r
        })
    }
}

function buildNodeHierarchy(e, t, s, n) {
    const i = s.nodes[e];
    return n.getDependency("node", e).then(function (e) {
        return void 0 === i.skin ? e : n.getDependency("skin", i.skin).then(function (t) {
            return e.traverse(function (e) {
                e.isSkinnedMesh && e.bind(t, e.matrixWorld)
            }), e
        })
    }).then(function (e) {
        t.add(e);
        const r = [];
        if (i.children) {
            const t = i.children;
            for (let i = 0, o = t.length; i < o; i++) {
                const o = t[i];
                r.push(buildNodeHierarchy(o, e, s, n))
            }
        }
        return Promise.all(r)
    })
}

function computeBounds(e, t, s) {
    const n = t.attributes, i = new Box3;
    if (void 0 === n.POSITION) return;
    {
        const e = s.json.accessors[n.POSITION], t = e.min, r = e.max;
        if (void 0 === t || void 0 === r) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        if (i.set(new Vector3(t[0], t[1], t[2]), new Vector3(r[0], r[1], r[2])), e.normalized) {
            const t = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[e.componentType]);
            i.min.multiplyScalar(t), i.max.multiplyScalar(t)
        }
    }
    const r = t.targets;
    if (void 0 !== r) {
        const e = new Vector3, t = new Vector3;
        for (let n = 0, i = r.length; n < i; n++) {
            const i = r[n];
            if (void 0 !== i.POSITION) {
                const n = s.json.accessors[i.POSITION], r = n.min, o = n.max;
                if (void 0 !== r && void 0 !== o) {
                    if (t.setX(Math.max(Math.abs(r[0]), Math.abs(o[0]))), t.setY(Math.max(Math.abs(r[1]), Math.abs(o[1]))), t.setZ(Math.max(Math.abs(r[2]), Math.abs(o[2]))), n.normalized) {
                        const e = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[n.componentType]);
                        t.multiplyScalar(e)
                    }
                    e.max(t)
                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(e)
    }
    e.boundingBox = i;
    const o = new Sphere;
    i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = o
}

function addPrimitiveAttributes(e, t, s) {
    const n = t.attributes, i = [];

    function r(t, n) {
        return s.getDependency("accessor", t).then(function (t) {
            e.setAttribute(n, t)
        })
    }

    for (const t in n) {
        const s = ATTRIBUTES[t] || t.toLowerCase();
        s in e.attributes || i.push(r(n[t], s))
    }
    if (void 0 !== t.indices && !e.index) {
        const n = s.getDependency("accessor", t.indices).then(function (t) {
            e.setIndex(t)
        });
        i.push(n)
    }
    return assignExtrasToUserData(e, t), computeBounds(e, t, s), Promise.all(i).then(function () {
        return void 0 !== t.targets ? addMorphTargets(e, t.targets, s) : e
    })
}

function toTrianglesDrawMode(e, t) {
    let s = e.getIndex();
    if (null === s) {
        const t = [], n = e.getAttribute("position");
        if (void 0 === n) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
        for (let e = 0; e < n.count; e++) t.push(e);
        e.setIndex(t), s = e.getIndex()
    }
    const n = s.count - 2, i = [];
    if (t === TriangleFanDrawMode) for (let e = 1; e <= n; e++) i.push(s.getX(0)), i.push(s.getX(e)), i.push(s.getX(e + 1)); else for (let e = 0; e < n; e++) e % 2 == 0 ? (i.push(s.getX(e)), i.push(s.getX(e + 1)), i.push(s.getX(e + 2))) : (i.push(s.getX(e + 2)), i.push(s.getX(e + 1)), i.push(s.getX(e)));
    i.length / 3 !== n && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = e.clone();
    return r.setIndex(i), r
}

function isObjEmpty(e) {
    return void 0 === e || "undefined" === e || null == e || "" === e || 0 === e.length || "object" == typeof e && 0 === Object.keys(e).length
}

function isPhone() {
    return navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)
}

new Vue({
    el: "#app", data: () => ({
        camera: null,
        width: document.documentElement.clientWidth || window.innerWidth,
        height: document.documentElement.clientHeight || window.innerHeight,
        canvasWidth: 0,
        canvasHeight: 0,
        actionShow: !1,
        deviceList: [],
        isCameraOpen: !1,
        task: null,
        model: null,
        modelLoad: !0,
        deviceId: localStorage.getItem("deviceId") || "user",
        flipHorizontal: !1,
        scene: null,
        threeCamera: null,
        renderer: null,
        geometry: null,
        background: null,
        mesh: null,
        Object3D: null,
        morphTarget: null,
        meshPopup: !1,
        meshIndex: 0,
        meshListAll: [{
            name: "",
            src: "https://dcdn.it120.cc/2022/12/14/cb57d900-8597-4c70-b34d-2966dc428bc7.png",
            srcX: "https://dcdn.it120.cc/2022/12/14/3f1e0c82-3455-4896-9ea3-d19541db52be.png"
        }, {
            name: "",
            src: "https://dcdn.it120.cc/2022/12/06/795dea0b-76e9-48b8-a162-20b29d2731a7.png"
        }, {
            name: "3D",
            src: "https://dcdn.it120.cc/2022/12/09/770e9c62-2fb6-4899-8b3e-93437cbaddfb.png"
        }, {
            name: "",
            type: "model",
            src: "https://dcdn.it120.cc/2022/12/07/e64174b8-a96c-4f36-9b70-9ed5c952f4df.png",
            model: "https://dcdn.it120.cc/2022/12/07/55607c9c-1aaa-494a-b332-6a5360933c4a.glb"
        }, {
            name: "",
            type: "model",
            src: "https://dcdn.it120.cc/2022/12/07/208ccc82-94db-4aab-a431-c7531ec190a3.png",
            model: "https://dcdn.it120.cc/2022/12/07/4c4096b0-fd19-4a1b-886c-7b263c35dfe9.glb"
        }, {
            name: "(test)",
            calculateFun: "Heartglasses",
            type: "model",
            src: "https://dcdn.it120.cc/2022/12/07/e6fa3b86-863c-4d6e-844c-0e1cd03bf32c.png",
            model: "https://dcdn.it120.cc/2022/12/07/752de96c-bc3f-4fab-b73f-12626dad8977.glb"
        }],
        meshList: [],
        helpTextModel: ["0"],
        tabsActive: "stickers"
    }), async mounted() {
        isPhone() && (this.flipHorizontal = !0), await this.getData(), this.$dialog.alert({
            message: '\n                <div class="prompt-text">\n                    <h5>AR</h5>\n                    <ol>\n                        <li>1-2</li>\n                        <li></li>\n                        <li></li>\n                    </ol>\n                </div>',
            theme: "round-button",
            className: "helpdialog",
            confirmButtonText: ""
        }).then(() => {
            this.cameraInit(), this.openCamera()
        })
    }, async beforeDestroy() {
        this.isCameraOpen = !1, window.cancelAnimationFrame(this.task), this.mesh && this.scene.remove(this.mesh), this.geometry && this.scene.remove(this.geometry), this.renderer && this.renderer.dispose(), this.threeCamera = null, this.camera && await this.camera.stop()
    }, methods: {
        isEmpty: e => isObjEmpty(e), tabsChange() {
            const e = this.tabsActive;
            this.meshIndex = -1, this.mesh && this.scene.remove(this.mesh), this.Object3D && (this.Object3D.visible = !1), this.geometry && this.scene.remove(this.geometry), "stickers" == e && (this.meshList = this.meshListAll.filter(e => "model" != e.type)), "3Dmodel" == e && (this.meshList = this.meshListAll.filter(e => "model" === e.type))
        }, async getData() {
            const e = this.$toast.loading({ duration: 0, forbidClick: !0, message: "" });
            try {
                const t = "https://web-1254176432.cos.ap-shanghai.myqcloud.com/faceMesh/data.json",
                    s = await fetch(`${ t }?s=${ (new Date).getDate() }_${ (new Date).getHours() }`).then(e => e.json());
                this.meshListAll = s, this.tabsChange()
            } catch (e) {
                console.log("getData", e)
            } finally {
                e.clear()
            }
        }, uploaderImage(e) {
            const t = this.$toast.loading({ duration: 0, forbidClick: !0, message: "loading" }),
                s = window.URL && window.URL.createObjectURL(e);
            return e.type.includes("image/") ? (this.meshList.push({
                src: s,
                name: e.name
            }), this.meshListAll.push({
                src: s,
                name: e.name
            }), t.clear()) : (t.clear(), this.$toast("-" + e.type)), !1
        }, uploaderGlb(e) {
            const t = this.$toast.loading({ duration: 0, forbidClick: !0, message: "loading" }),
                s = window.URL && window.URL.createObjectURL(e);
            return e.name.includes(".glb") ? (this.meshListAll.push({
                model: s,
                type: "model",
                name: e.name
            }), this.meshList.push({
                model: s,
                type: "model",
                name: e.name
            }), t.clear()) : (t.clear(), this.$toast("-" + e.type)), !1
        }, Create3dScene() {
            let e = this.canvasWidth, t = this.canvasHeight, s = this.$refs.video, n = this.$refs.canvas;
            const i = new THREE.Scene, r = new THREE.VideoTexture(s),
                o = new THREE.Mesh(new THREE.PlaneGeometry(e, t), new THREE.MeshBasicMaterial({ map: r }));
            o.position.set(0, 0, -1e3), i.add(o);
            const a = new THREE.OrthographicCamera(e / -2, e / 2, t / 2, t / -2, 0, 2e3);
            a.position.set(0, 0, 1e3), a.lookAt(i.position);
            const c = new THREE.HemisphereLight(16777215, 16777215, .3);
            i.add(c);
            const l = new THREE.AmbientLight(16777215, .7);
            i.add(l);
            const h = new THREE.DirectionalLight(16777215, .7);
            h.position.set(.5, 0, .866), i.add(h);
            const d = new THREE.WebGLRenderer({ canvas: n, alpha: !0, antialias: !0 });
            d.setPixelRatio(window.devicePixelRatio), d.setSize(e, t), this.scene = i, this.threeCamera = a, this.background = o, this.renderer = d, this.changeMesh()
        }, changeMesh(e = 0) {
            if (-1 !== e) {
                if ("stickers" == this.tabsActive) {
                    const t = this.$toast.loading({ duration: 0, forbidClick: !0, message: "" });
                    try {
                        this.mesh && this.scene.remove(this.mesh), this.geometry && this.scene.remove(this.geometry);
                        const s = new THREE.BufferGeometry;
                        s.setIndex(TRIANGULATION), s.setAttribute("uv", new THREE.Float32BufferAttribute(UVS.map((e, t) => t % 2 ? e : 1 - e), 2)), s.computeVertexNormals(), this.geometry = s;
                        const n = new THREE.TextureLoader, { src: i, srcX: r } = this.meshList[e];
                        n.load(this.flipHorizontal ? i : r || i, n => {
                            n.encoding = THREE.sRGBEncoding, n.anisotropy = 16;
                            const i = new THREE.MeshBasicMaterial({
                                map: n,
                                transparent: !0,
                                color: new THREE.Color(16777215),
                                reflectivity: .5
                            }), r = new THREE.Mesh(s, i);
                            this.scene.add(r), this.mesh = r, this.meshIndex = e, this.meshPopup = !1, t.clear()
                        })
                    } catch (e) {
                        console.log(e), t.clear(), this.$toast("")
                    }
                }
                if ("3Dmodel" == this.tabsActive) {
                    const t = this.$toast.loading({ duration: 0, forbidClick: !0, message: "3D" });
                    try {
                        const s = this.meshList[e].model;
                        console.log("modelUrl", s);
                        const n = new GLTFLoader, i = new THREE.Object3D;
                        this.Object3D && this.scene.remove(this.Object3D), i.position.set(0, 0, 0), n.load(s, s => {
                            const n = s.scene, r = (new THREE.Box3).setFromObject(n),
                                o = (r.getSize(new THREE.Vector3).length(), r.getCenter(new THREE.Vector3));
                            n.position.x += n.position.x - o.x, n.position.y += n.position.y - o.y + 1, n.position.z += n.position.z - o.z - 15, i.add(n), this.scene.add(i), this.morphTarget = this.findMorphTarget(n), this.Object3D = i, this.meshIndex = e, this.meshPopup = !1, t.clear(), console.log("", this.morphTarget)
                        })
                    } catch (e) {
                        console.log(e), t.clear(), this.$toast("")
                    }
                }
            }
        }, renderStickers(e) {
            e && this.updateGeometry(e), this.renderer.render(this.scene, this.threeCamera)
        }, updateGeometry(e) {
            let t = this.canvasWidth, s = this.canvasHeight;
            const n = this.resolveMesh(e.scaledMesh, t, s).reduce((e, t) => e.concat(t), []);
            this.geometry.setAttribute("position", new THREE.Float32BufferAttribute(n, 3)), this.geometry.attributes.position.needsUpdate = !0
        }, track(e, t) {
            try {
                const s = t.midwayBetweenEyes[0], n = this.getScale(t.scaledMesh, 234, 454),
                    i = this.getRotation(t.scaledMesh, 10, 50, 280);
                e.position.set(...s), e.scale.setScalar(n / 20), e.scale.x *= -1, e.rotation.setFromRotationMatrix(i), e.rotation.y = -e.rotation.y, e.rotateZ(Math.PI), e.rotateX(.05 * -Math.PI), this.morphTarget && (this.morphTarget.leftEye && this.morphTarget.leftEye(1 - t.faceRig.eye.r), this.morphTarget.rightEye && this.morphTarget.rightEye(1 - t.faceRig.eye.l), this.morphTarget.mouth && this.morphTarget.mouth(t.faceRig.mouth.shape.A))
            } catch (e) {
            }
        }, trackHeartglasses(e, t) {
            try {
                const s = [168].map(e => t.faceMesh[e])[0], n = this.getScale(t.scaledMesh, 234, 454),
                    i = this.getRotation(t.scaledMesh, 10, 50, 280);
                e.position.set(...s), e.scale.setScalar(n / 17), e.scale.x *= -1, e.rotation.setFromRotationMatrix(i), e.rotation.y = -e.rotation.y, e.rotateZ(Math.PI), e.rotateX(.1 * -Math.PI)
            } catch (e) {
                console.log(e)
            }
        }, findMorphTarget(e, t) {
            const s = {}, n = e => {
                if ("Mesh" === e.type && e.morphTargetInfluences) {
                    const t = e;
                    Object.keys(t.morphTargetDictionary).forEach(e => {
                        s[e] = (s => {
                            t.morphTargetInfluences[t.morphTargetDictionary[e]] = s
                        })
                    })
                }
                e.children.forEach(n)
            };
            return n(e), s
        }, getScale(e, t = 0, s = 1) {
            const n = new THREE.Vector3(...e[t]), i = new THREE.Vector3(...e[s]);
            return n.distanceTo(i)
        }, getRotation(e, t = 0, s = 1, n = 2) {
            const i = new THREE.Vector3(...e[t]), r = new THREE.Vector3(...e[s]), o = new THREE.Vector3(...e[n]),
                a = new THREE.Matrix4, c = r.clone().sub(o).normalize(),
                l = r.clone().add(o).multiplyScalar(.5).sub(i).multiplyScalar(-1).normalize(),
                h = (new THREE.Vector3).crossVectors(c, l).normalize();
            return a.makeBasis(c, l, h).invert()
        }, render3D(e) {
            if (e) {
                const { calculateFun: t } = this.meshList[this.meshIndex] || {};
                this.isEmpty(t) ? this.track(this.Object3D, e) : "Heartglasses" === t && this.trackHeartglasses(this.Object3D, e)
            }
            this.renderer.render(this.scene, this.threeCamera)
        }, resolveMesh(e, t = this.canvasWidth, s = this.canvasHeight) {
            return e.map(e => [e[0] - t / 2, s / 2 - e[1], -e[2]])
        }, async triggerToggleFlipHorizontal() {
            this.flipHorizontal = !this.flipHorizontal, "stickers" == this.tabsActive && this.changeMesh(this.meshIndex)
        }, actionSelect(e) {
            const { deviceId: t } = e;
            this.actionShow = !1, isObjEmpty(t) || this.deviceId == t || (this.deviceId = t, window.localStorage.setItem("deviceId", t), this.openCamera())
        }, async getMediaDevices() {
            let e = await this.camera.getMediaDevices();
            this.deviceList = e.map(e => (e.name = e.label || e.deviceId, e.color = e.deviceId == this.deviceId ? "#1989fa" : "#323233", e))
        }, async cameraInit() {
            const e = this.$refs.video;
            this.width > 960 && (this.width = 960, this.height = 540), this.camera = new Camera(e, {
                audio: !1,
                video: isPhone() ? { frameRate: 60 } : { width: this.width, height: this.height, frameRate: 60 }
            }), await this.getMediaDevices()
        }, openCamera() {
            const e = this.$toast.loading({ duration: 0, forbidClick: !0, message: "" });
            this.isCameraOpen = !1, this.camera.open(this.deviceId).then(async e => {
                const t = this.$refs.video, { videoWidth: s, videoHeight: n } = t, {
                    clientWidth: i,
                    clientHeight: r
                } = t;
                this.canvasWidth = s, this.canvasHeight = n, t.style.width = s + "px", t.style.height = n + "px", this.$refs.wrapper.style.width = i + "px", this.$refs.wrapper.style.height = s / i * r + "px", this.isCameraOpen = !0, e.settings && e.settings.deviceId && (this.deviceId = e.settings.deviceId, 0 === this.deviceList.filter(e => e.deviceId == this.deviceId).length && this.deviceList.unshift({
                    color: "#1989fa",
                    name: e.label || "[]",
                    deviceId: this.deviceId
                }), window.localStorage.setItem("deviceId", this.deviceId)), await this.createModel(), this.Create3dScene(), window.cancelAnimationFrame(this.task), this.task = window.requestAnimationFrame(this.recognition)
            }).catch(e => {
                console.log(e), this.$dialog.alert({
                    title: "",
                    message: `${ e.errMsg }`,
                    theme: "round-button"
                }).then(() => {
                    location.reload()
                })
            }).finally(() => {
                e.clear()
            })
        }, createModel() {
            return new Promise(async e => {
                this.modelLoad = !0;
                const t = this.$toast.loading({ duration: 0, forbidClick: !0, message: "" });
                await tf.setBackend("webgl");
                const s = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;
                this.model = await faceLandmarksDetection.createDetector(s, {
                    maxFaces: 1,
                    refineLandmarks: !0,
                    runtime: "mediapipe",
                    solutionPath: "https://unpkg.com/@mediapipe/face_mesh"
                }), t.clear(), this.modelLoad = !1, e(this.model)
            })
        }, async recognition() {
            try {
                if (this.isCameraOpen && !this.modelLoad && !this.isPause) {
                    const s = this.$refs.video, n = await this.model.estimateFaces(s, { flipHorizontal: !1 });
                    if ("stickers" == this.tabsActive) if (n.length > 0) {
                        var e = n[0].keypoints;
                        this.renderStickers({ scaledMesh: e.reduce((e, t) => (e.push([t.x, t.y, t.z]), e), []) })
                    } else this.renderStickers({ scaledMesh: [] });
                    if ("3Dmodel" == this.tabsActive) if (n.length > 0) {
                        var t = (e = n[0].keypoints).reduce((e, t) => (e.push([t.x, t.y, t.z]), e), []);
                        const i = this.resolveMesh(t), r = Kalidokit.Face.solve(e, {
                            runtime: "mediapipe",
                            video: s,
                            imageSize: { height: this.canvasHeight, width: this.canvasWidth },
                            smoothBlink: !1,
                            blinkSettings: [.25, .75]
                        });
                        this.Object3D && (this.Object3D.visible = !0), this.render3D({
                            midwayBetweenEyes: [168].map(e => i[e]),
                            scaledMesh: t,
                            faceMesh: i,
                            faceRig: r
                        })
                    } else this.Object3D && (this.Object3D.visible = !1), this.renderer.render(this.scene, this.threeCamera)
                }
                this.task = window.requestAnimationFrame(this.recognition)
            } catch (e) {
                console.log(e), this.task = window.requestAnimationFrame(this.recognition)
            }
        }
    }
});